{"version":3,"file":"qiniu4js.es.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 5d31703e51cd4702f6cb","webpack:///./src/util/Log.ts","webpack:///./src/upload/Uploader.ts","webpack:///./src/upload/UploaderBuilder.ts","webpack:///./src/upload/task/BaseTask.ts","webpack:///./src/Main.ts","webpack:///./src/upload/hook/SimpleUploadListener.ts","webpack:///./src/upload/interceptor/SimpleUploadInterceptor.ts","webpack:///./src/upload/pattren/ChunkUploadPattern.ts","webpack:///./src/upload/pattren/DirectUploadPattern.ts","webpack:///./src/upload/task/ChunkTask.ts","webpack:///./src/upload/task/DirectTask.ts","webpack:///./src/upload/uuid/UUID.ts","webpack:///./src/util/Polyfill.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Qiniu\"] = factory();\n\telse\n\t\troot[\"Qiniu\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5d31703e51cd4702f6cb","class Log {\n    static get enable() {\n        return this._enable;\n    }\n    static set enable(value) {\n        this._enable = value;\n    }\n    static d(object) {\n        if (!Log._enable) {\n            return;\n        }\n        console.debug(object);\n    }\n\n    static l(object) {\n        if (!Log._enable) {\n            return;\n        }\n        console.log(object);\n    }\n    static e(object) {\n        if (!Log._enable) {\n            return;\n        }\n        console.error(object);\n    }\n    static w(object) {\n        if (!Log._enable) {\n            return;\n        }\n        console.warn(object);\n    }\n    static i(object) {\n        if (!Log._enable) {\n            return;\n        }\n        console.info(object);\n    }\n}\nLog._enable = false;\nexport default Log;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/Log.ts\n// module id = 0\n// module chunks = 0","import DirectTask from \"./task/DirectTask\";\nimport { ChunkTask } from \"./task/ChunkTask\";\nimport UUID from \"./uuid/UUID\";\nimport UploaderBuilder from \"./UploaderBuilder\";\nimport log from \"../util/Log\";\nimport SimpleUploadListener from \"./hook/SimpleUploadListener\";\nimport DirectUploadPattern from \"./pattren/DirectUploadPattern\";\nimport ChunkUploadPattern from \"./pattren/ChunkUploadPattern\";\nimport \"../util/Polyfill\";\nclass Uploader {\n    constructor(builder) {\n        this.FILE_INPUT_EL_ID = 'qiniu4js-input';\n        this._taskQueue = []; //任务队列\n        this._tasking = false; //任务执行中\n        this._scale = []; //缩放大小,限定高度等比缩放[h:200,w:0],限定宽度等比缩放[h:0,w:100],限定长宽[h:200,w:100]\n        this._saveKey = false;\n        /**\n         * 处理文件\n         */\n        this.handleFiles = () => {\n            //如果没有选中文件就返回\n            if (this.fileInput.files.length == 0) {\n                return;\n            }\n            //生成task\n            this.generateTask();\n            //是否中断任务\n            let isInterrupt = false;\n            let interceptedTasks = [];\n            //任务拦截器过滤\n            for (let task of this.taskQueue) {\n                for (let interceptor of this.interceptors) {\n                    //拦截生效\n                    if (interceptor.onIntercept(task, this.taskQueue)) {\n                        interceptedTasks.push(task);\n                        log.d(\"任务拦截器拦截了任务:\");\n                        log.d(task);\n                    }\n                    //打断生效\n                    if (interceptor.onInterrupt(task, this.taskQueue)) {\n                        //将打断标志位设为true\n                        isInterrupt = true;\n                        break;\n                    }\n                }\n            }\n            if (isInterrupt) {\n                log.w(\"任务拦截器中断了任务队列\");\n                return;\n            }\n            //从任务队列中去除任务\n            for (let task of interceptedTasks) {\n                let index = this.taskQueue.indexOf(task);\n                if (index != -1) {\n                    this.taskQueue.splice(index, 1);\n                }\n            }\n            //回调函数函数\n            this.listener.onReady(this.taskQueue);\n            //处理图片\n            this.handleImages().then(() => {\n                //自动上传\n                if (this.auto) {\n                    log.d(\"开始自动上传\");\n                    this.start();\n                }\n            });\n        };\n        this.resolveUUID = s => {\n            let re = /\\$\\(uuid\\)/;\n            if (re.test(s)) {\n                return s.replace(re, UUID.uuid());\n            }\n            return s;\n        };\n        this.resolveImageInfo = (blob, s) => {\n            let widthRe = /\\$\\(imageInfo\\.width\\)/;\n            let heightRe = /\\$\\(imageInfo\\.height\\)/;\n            if (!widthRe.test(s) && !heightRe.test(s)) {\n                return Promise.resolve(s);\n            }\n            return new Promise(resolve => {\n                let img = new Image();\n                img.src = URL.createObjectURL(blob);\n                img.onload = () => {\n                    s = s.replace(widthRe, img.width.toString());\n                    s = s.replace(heightRe, img.height.toString());\n                    resolve(s);\n                };\n            });\n        };\n        this.onSaveKeyResolved = saveKey => {\n            this._tokenShare = this._tokenShare && this._saveKey == saveKey;\n            return saveKey;\n        };\n        this._retry = builder.getRetry;\n        this._size = builder.getSize;\n        this._chunk = builder.getChunk;\n        this._auto = builder.getAuto;\n        this._multiple = builder.getMultiple;\n        this._accept = builder.getAccept;\n        this._button = builder.getButton;\n        this._buttonEventName = builder.getButtonEventName;\n        this._compress = builder.getCompress;\n        this._scale = builder.getScale;\n        this._saveKey = builder.getSaveKey;\n        this._tokenFunc = builder.getTokenFunc;\n        this._tokenShare = builder.getTokenShare;\n        this._listener = Object.assign(new SimpleUploadListener(), builder.getListener);\n        this._interceptors = builder.getInterceptors;\n        this._domain = builder.getDomain;\n        this._fileInputId = `${this.FILE_INPUT_EL_ID}_${new Date().getTime()}`;\n        log.enable = builder.getIsDebug;\n        this.validateOptions();\n        this.init();\n    }\n    /**\n     * 初始化操作\n     */\n    init() {\n        this.initFileInputEl();\n    }\n    /**\n     * 初始化file input element\n     */\n    initFileInputEl() {\n        //查询已经存在的file input\n        let exist = document.getElementById(this._fileInputId);\n        //创建input元素\n        this._fileInput = exist ? exist : document.createElement('input');\n        this.fileInput.type = 'file'; //type file\n        this.fileInput.id = this._fileInputId; //id 方便后面查找\n        this.fileInput.style.display = 'none'; //隐藏file input\n        //多文件\n        if (this.multiple) {\n            //多文件\n            this.fileInput.multiple = true;\n        }\n        //文件类型\n        if (this.accept && this.accept.length != 0) {\n            let acceptValue = '';\n            for (let value of this.accept) {\n                acceptValue += value;\n                acceptValue += ',';\n            }\n            if (acceptValue.endsWith(',')) {\n                acceptValue = acceptValue.substring(0, acceptValue.length - 1);\n            }\n            this.fileInput.accept = acceptValue;\n            log.d(`accept类型 ${acceptValue}`);\n        }\n        //将input元素添加到body子节点的末尾\n        document.body.appendChild(this.fileInput);\n        //选择文件监听器\n        this.fileInput.addEventListener('change', this.handleFiles, false);\n        if (this._button != undefined) {\n            let button = document.getElementById(this._button);\n            button.addEventListener(this._buttonEventName, this.chooseFile.bind(this));\n        }\n    }\n    /**\n     * 上传完成或者失败后,对本次上传任务进行清扫\n     */\n    resetUploader() {\n        log.d(\"开始重置 uploader\");\n        this.taskQueue.length = 0;\n        log.d(\"任务队列已清空\");\n        this._token = null;\n        log.d(\"token已清空\");\n        log.d(\"uploader 重置完毕\");\n    }\n    /**\n     * 是否是分块任务\n     * @param task\n     * @returns {boolean}\n     */\n    static isChunkTask(task) {\n        return task.constructor.name === ChunkTask.name && task instanceof ChunkTask;\n    }\n    /**\n     * 是否是直传任务\n     * @param task\n     * @returns {boolean}\n     */\n    static isDirectTask(task) {\n        return task.constructor.name === DirectTask.name && task instanceof DirectTask;\n    }\n    /**\n     * 生成task\n     */\n    generateTask() {\n        this.resetUploader();\n        let files = this.fileInput.files;\n        //遍历files 创建上传任务\n        for (let i = 0; i < this.fileInput.files.length; i++) {\n            let file = files[i];\n            let task;\n            //只有在开启分块上传，并且文件大小大于4mb的时候才进行分块上传\n            if (this.chunk && file.size > UploaderBuilder.BLOCK_SIZE) {\n                task = new ChunkTask(file, UploaderBuilder.BLOCK_SIZE, this.size);\n            } else {\n                task = new DirectTask(file);\n            }\n            if (this._saveKey == false) {\n                task.key = this.listener.onTaskGetKey(task);\n            }\n            this.taskQueue.push(task);\n        }\n    }\n    /**\n     * 处理图片-缩放-质量压缩\n     */\n    handleImages() {\n        let promises = [];\n        if (this.compress != 1 || this.scale[0] != 0 || this.scale[1] != 0) {\n            for (let task of this.taskQueue) {\n                if (!task.file.type.match('image.*')) {\n                    continue;\n                }\n                log.d(`${task.file.name} 处理前的图片大小:${task.file.size / 1024} kb`);\n                let canvas = document.createElement('canvas');\n                let img = new Image();\n                let ctx = canvas.getContext('2d');\n                img.src = URL.createObjectURL(task.file);\n                let _this = this;\n                promises.push(new Promise(resolve => img.onload = () => {\n                    let imgW = img.width;\n                    let imgH = img.height;\n                    let scaleW = _this.scale[0];\n                    let scaleH = _this.scale[1];\n                    if (scaleW == 0 && scaleH > 0) {\n                        canvas.width = imgW / imgH * scaleH;\n                        canvas.height = scaleH;\n                    } else if (scaleH == 0 && scaleW > 0) {\n                        canvas.width = scaleW;\n                        canvas.height = imgH / imgW * scaleW;\n                    } else if (scaleW > 0 && scaleH > 0) {\n                        canvas.width = scaleW;\n                        canvas.height = scaleH;\n                    } else {\n                        canvas.width = img.width;\n                        canvas.height = img.height;\n                    }\n                    //这里的长宽是绘制到画布上的图片的长宽\n                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n                    console.log(canvas);\n                    console.log(canvas.toBlob);\n                    //0.95是最接近原图大小，如果质量为1的话会导致比原图大几倍。\n                    canvas.toBlob(blob => {\n                        resolve(blob);\n                        log.d(`${task.file.name} 处理后的图片大小:${blob.size / 1024} kb`);\n                    }, \"image/jpeg\", _this.compress * 0.95);\n                }).then(blob => {\n                    blob.name = task.file.name;\n                    task.file = blob;\n                    if (Uploader.isChunkTask(task)) {\n                        task.spliceFile2Block();\n                    }\n                }));\n            }\n        }\n        return Promise.all(promises);\n    }\n    /**\n     * 检验选项合法性\n     */\n    validateOptions() {\n        log.d(\"开始检查构建参数合法性\");\n        if (!this._tokenFunc) {\n            throw new Error('你必须提供一个获取Token的回调函数');\n        }\n        if (!this.scale || !(this.scale instanceof Array) || this.scale.length != 2 || this.scale[0] < 0 || this.scale[1] < 0) {\n            throw new Error('scale必须是长度为2的number类型的数组,scale[0]为宽度，scale[1]为长度,必须大于等于0');\n        }\n        log.d(\"构建参数检查完毕\");\n    }\n    /**\n     * 开始上传\n     */\n    start() {\n        log.d(`上传任务遍历开始`);\n        if (this.fileInput.files.length == 0) {\n            throw new Error('没有选中的文件，无法开始上传');\n        }\n        if (this.tasking) {\n            throw new Error('任务执行中，请不要重复上传');\n        }\n        this.listener.onStart(this.taskQueue);\n        //遍历任务队列\n        for (let task of this.taskQueue) {\n            log.d(`上传文件名：${task.file.name}`);\n            log.d(`上传文件大小：${task.file.size}字节，${task.file.size / 1024} kb，${task.file.size / 1024 / 1024} mb`);\n            //根据任务的类型调用不同的上传模式进行上传\n            if (Uploader.isDirectTask(task)) {\n                log.d('该上传任务为直传任务');\n                //直传\n                new DirectUploadPattern(this).upload(task);\n            } else if (Uploader.isChunkTask(task)) {\n                log.d('该上传任务为分片任务');\n                //分块上传\n                new ChunkUploadPattern(this).upload(task);\n            } else {\n                throw new Error('非法的task类型');\n            }\n        }\n    }\n    /**\n     * 所有任务是否完成\n     * @returns {boolean}\n     */\n    isTaskQueueFinish() {\n        for (let task of this.taskQueue) {\n            if (!task.isFinish) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * 选择文件\n     */\n    chooseFile() {\n        this.fileInput.click();\n    }\n    getToken(task) {\n        if (this._tokenShare && this._token != undefined) {\n            return Promise.resolve(this._token);\n        }\n        log.d(`开始获取上传token`);\n        return Promise.resolve(this._tokenFunc(this, task)).then(token => {\n            log.d(`上传token获取成功: ${token}`);\n            this._token = token;\n            return token;\n        });\n    }\n    requestTaskToken(task, url) {\n        return this.resolveSaveKey(task).then(saveKey => {\n            return this.requestToken(url, saveKey);\n        });\n    }\n    requestToken(url, saveKey) {\n        return new Promise((resolve, reject) => {\n            if (typeof saveKey == \"string\") {\n                url += (/\\?/.test(url) ? \"&\" : \"?\") + \"saveKey=\" + encodeURIComponent(saveKey);\n            }\n            url += (/\\?/.test(url) ? \"&\" : \"?\") + new Date().getTime();\n            let xhr = new XMLHttpRequest();\n            xhr.open('GET', url, true);\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState != XMLHttpRequest.DONE) {\n                    return;\n                }\n                if (xhr.status == 200) {\n                    resolve(xhr.response.uptoken);\n                    return;\n                }\n                reject(xhr.response);\n            };\n            xhr.onabort = () => {\n                reject('aborted');\n            };\n            xhr.responseType = 'json';\n            xhr.send();\n        });\n    }\n    resolveSaveKey(task) {\n        let saveKey = this._saveKey;\n        if (typeof saveKey != \"string\") {\n            return Promise.resolve(undefined);\n        }\n        return Promise.resolve(saveKey).then(this.resolveUUID).then(saveKey => this.resolveImageInfo(task.file, saveKey)).then(this.onSaveKeyResolved);\n    }\n    get retry() {\n        return this._retry;\n    }\n    get size() {\n        return this._size;\n    }\n    get auto() {\n        return this._auto;\n    }\n    get multiple() {\n        return this._multiple;\n    }\n    get accept() {\n        return this._accept;\n    }\n    get compress() {\n        return this._compress;\n    }\n    get scale() {\n        return this._scale;\n    }\n    get listener() {\n        return this._listener;\n    }\n    get fileInput() {\n        return this._fileInput;\n    }\n    get chunk() {\n        return this._chunk;\n    }\n    get taskQueue() {\n        return this._taskQueue;\n    }\n    get tasking() {\n        return this._tasking;\n    }\n    set tasking(value) {\n        this._tasking = value;\n    }\n    get interceptors() {\n        return this._interceptors;\n    }\n    get domain() {\n        return this._domain;\n    }\n}\nexport default Uploader;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/Uploader.ts\n// module id = 1\n// module chunks = 0","import Uploader from \"./Uploader\";\nimport SimpleUploadInterceptor from \"./interceptor/SimpleUploadInterceptor\";\n/**\n * UploaderBuilder\n *\n */\nclass UploaderBuilder {\n    constructor() {\n        this._retry = 0; //最大重试次数\n        this._domain = UploaderBuilder.UPLOAD_DOMAIN; //上传域名\n        this._scheme = null; //上传域名的 scheme\n        this._size = 1024 * 1024; //分片大小,单位字节,上限4m,不能为0\n        this._chunk = true; //分块上传\n        this._auto = true; //自动上传,每次选择文件后\n        this._multiple = true; //是否支持多文件\n        this._accept = []; //接受的文件类型\n        this._compress = 1; //图片压缩质量\n        this._scale = [0, 0]; //缩放大小,限定高度等比[h:200,w:0],限定宽度等比[h:0,w:100],限定长宽[h:200,w:100]\n        this._saveKey = false;\n        this._tokenShare = true; //分享token,如果为false,每一次HTTP请求都需要新获取Token\n        this._interceptors = []; //任务拦截器\n        this._isDebug = false; //\n    }\n    /**\n     * 设置上传的域名,默认是 {http: 'http://upload.qiniu.com', https: 'https://up.qbox.me'}\n     * @param domain\n     * @returns {UploaderBuilder}\n     */\n    domain(domain) {\n        this._domain = domain;\n        return this;\n    }\n    /**\n     * 设置上传域名的协议类型，默认从 window.location.protocol 读取\n     * @param scheme\n     * @returns {UploaderBuilder}\n     */\n    scheme(scheme) {\n        this._scheme = scheme;\n        return this;\n    }\n    /**\n     * 添加一个拦截器\n     * @param interceptor\n     * @returns {UploaderBuilder}\n     */\n    interceptor(interceptor) {\n        this._interceptors.push(Object.assign(new SimpleUploadInterceptor(), interceptor));\n        return this;\n    }\n    /**\n     * 上传失败后的重传尝试次数\n     * @param retry 默认0次，不尝试次重传\n     * @returns {UploaderBuilder}\n     */\n    retry(retry) {\n        this._retry = retry;\n        return this;\n    }\n    /**\n     * 设置分片大小\n     * @param size 分块大小,单位字节,默认4*1024*1024字节(4mb)\n     * @returns {UploaderBuilder}\n     */\n    size(size) {\n        this._size = Math.min(Math.max(size, 1), UploaderBuilder.MAX_CHUNK_SIZE);\n        return this;\n    }\n    /**\n     * 选择文件后,是否自动上传\n     * @param auto 默认true\n     * @returns {UploaderBuilder}\n     */\n    auto(auto) {\n        this._auto = auto;\n        return this;\n    }\n    /**\n     * 是否支持多文件选择\n     * @param multiple 默认true\n     * @returns {UploaderBuilder}\n     */\n    multiple(multiple) {\n        this._multiple = multiple;\n        return this;\n    }\n    /**\n     * 接受上传的文件类型\n     * @param accept 数组形式例如:['.png','video/*']\n     *\n     * 详细配置见http://www.w3schools.com/tags/att_input_accept.asp\n     *\n     * @returns {UploaderBuilder}\n     */\n    accept(accept) {\n        this._accept = accept;\n        return this;\n    }\n    /**\n     * 设置上传按钮\n     * @param button 上传按钮ID\n     * @param eventName 上传按钮的监听事件名称，默认为 \"click\" 。\n     * @returns {UploaderBuilder}\n     */\n    button(button, eventName = \"click\") {\n        this._button = button;\n        this._buttonEventName = eventName;\n        return this;\n    }\n    /**\n     * 图片质量压缩,只在上传的文件是图片的时候有效\n     * @param compress 0-1,默认1,不压缩\n     * @returns {UploaderBuilder}\n     */\n    compress(compress) {\n        this._compress = Math.max(Math.min(compress, 1), 0);\n        return this;\n    }\n    /**\n     * 图片缩放\n     * @returns {UploaderBuilder}\n     * @param scale\n     */\n    scale(scale) {\n        this._scale = scale;\n        return this;\n    }\n    /**\n     * 设置 saveKey\n     * @param saveKey\n     * @returns {UploaderBuilder}\n     */\n    saveKey(saveKey) {\n        this._saveKey = saveKey;\n        return this;\n    }\n    /**\n     * 获取Token的地址\n     * @param tokenUrl\n     * @returns {UploaderBuilder}\n     */\n    tokenUrl(tokenUrl) {\n        this._tokenFunc = (uploader, task) => {\n            return uploader.requestTaskToken(task, tokenUrl);\n        };\n        return this;\n    }\n    /**\n     * 获取Token的函数\n     * @param tokenFunc\n     * @returns {UploaderBuilder}\n     */\n    tokenFunc(tokenFunc) {\n        this._tokenFunc = (uploader, task) => {\n            return new Promise(resolve => {\n                tokenFunc(resolve, task);\n            });\n        };\n        return this;\n    }\n    /**\n     * 上传生命周期钩子\n     * @param listener\n     * @returns {UploaderBuilder}\n     */\n    listener(listener) {\n        this._listener = listener;\n        return this;\n    }\n    /**\n     * 是否分享token,如果为false每上传一个文件都需要请求一次Token。\n     * @param tokenShare\n     * @returns {UploaderBuilder}\n     */\n    tokenShare(tokenShare) {\n        this._tokenShare = tokenShare;\n        return this;\n    }\n    /**\n     * 是否分块上传\n     * @param chunk 默认false\n     * @returns {UploaderBuilder}\n     */\n    chunk(chunk) {\n        this._chunk = chunk;\n        return this;\n    }\n    /**\n     * 是否开启debug模式\n     * @param debug 默认false\n     * @returns {UploaderBuilder}\n     */\n    debug(debug) {\n        this._isDebug = debug;\n        return this;\n    }\n    get getRetry() {\n        return this._retry;\n    }\n    get getSize() {\n        return this._size;\n    }\n    get getAuto() {\n        return this._auto;\n    }\n    get getMultiple() {\n        return this._multiple;\n    }\n    get getAccept() {\n        return this._accept;\n    }\n    get getButton() {\n        return this._button;\n    }\n    get getButtonEventName() {\n        return this._buttonEventName;\n    }\n    get getCompress() {\n        return this._compress;\n    }\n    get getScale() {\n        return this._scale;\n    }\n    get getListener() {\n        return this._listener;\n    }\n    get getSaveKey() {\n        return this._saveKey;\n    }\n    get getTokenFunc() {\n        return this._tokenFunc;\n    }\n    get getTokenShare() {\n        return this._tokenShare;\n    }\n    get getChunk() {\n        return this._chunk;\n    }\n    get getIsDebug() {\n        return this._isDebug;\n    }\n    get getInterceptors() {\n        return this._interceptors;\n    }\n    get getDomain() {\n        let domain = this._domain;\n        if (!domain) {\n            domain = UploaderBuilder.UPLOAD_DOMAIN;\n        }\n        if (typeof domain != \"string\") {\n            let scheme = this._scheme;\n            if (typeof scheme != \"string\") {\n                let protocol = window.location.protocol;\n                scheme = protocol.substring(0, protocol.length - 1);\n            }\n            domain = domain[scheme];\n        }\n        return domain.endsWith('/') ? domain.substring(0, domain.length - 1) : domain;\n    }\n    build() {\n        return new Uploader(this);\n    }\n}\nUploaderBuilder.MAX_CHUNK_SIZE = 4 * 1024 * 1024; //分片最大值\nUploaderBuilder.BLOCK_SIZE = UploaderBuilder.MAX_CHUNK_SIZE; //分块大小，只有大于这个数才需要分块\nUploaderBuilder.UPLOAD_DOMAIN = { http: 'http://upload.qiniu.com', https: 'https://up.qbox.me' };\nexport default UploaderBuilder;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/UploaderBuilder.ts\n// module id = 2\n// module chunks = 0","/**\n * 上传任务\n */\nclass BaseTask {\n    constructor(file) {\n        this._retry = 0; //已重试次数\n        this._progress = 0; //任务进度,最大100\n        this._isSuccess = false; //是否上传成功\n        this._isFinish = false; //是否结束\n        this._file = file;\n        this._createDate = new Date();\n    }\n    get file() {\n        return this._file;\n    }\n    set file(file) {\n        this._file = file;\n    }\n    get retry() {\n        return this._retry;\n    }\n    set retry(value) {\n        this._retry = value;\n    }\n    get createDate() {\n        return this._createDate;\n    }\n    set createDate(value) {\n        this._createDate = value;\n    }\n    get startDate() {\n        return this._startDate;\n    }\n    set startDate(value) {\n        this._startDate = value;\n    }\n    get endDate() {\n        return this._endDate;\n    }\n    set endDate(value) {\n        this._endDate = value;\n    }\n    get isSuccess() {\n        return this._isSuccess;\n    }\n    set isSuccess(value) {\n        this._isSuccess = value;\n    }\n    get progress() {\n        return this._progress;\n    }\n    set progress(value) {\n        this._progress = Math.min(Math.max(0, value), 100);\n    }\n    get result() {\n        return this._result;\n    }\n    set result(value) {\n        this._result = value;\n    }\n    get error() {\n        return this._error;\n    }\n    set error(value) {\n        this._error = value;\n    }\n    get key() {\n        return this._key;\n    }\n    set key(value) {\n        this._key = value;\n    }\n    get isFinish() {\n        return this._isFinish;\n    }\n    set isFinish(value) {\n        this._isFinish = value;\n    }\n}\nexport default BaseTask;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/task/BaseTask.ts\n// module id = 3\n// module chunks = 0","import Uploader from \"./upload/Uploader\";\nimport UploaderBuilder from \"./upload/UploaderBuilder\";\nexport { Uploader, UploaderBuilder };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Main.ts\n// module id = 4\n// module chunks = 0","class SimpleUploadListener {\n    onReady(taskQueue) {}\n    onStart(taskQueue) {}\n    onTaskProgress(task) {}\n    onTaskGetKey(task) {\n        return null;\n    }\n    onTaskFail(task) {}\n    onTaskSuccess(task) {}\n    onTaskRetry(task) {}\n    onFinish(taskQueue) {}\n}\nexport default SimpleUploadListener;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/hook/SimpleUploadListener.ts\n// module id = 5\n// module chunks = 0","class SimpleUploadInterceptor {\n    onIntercept(task) {\n        return false;\n    }\n    onInterrupt(task) {\n        return false;\n    }\n}\nexport default SimpleUploadInterceptor;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/interceptor/SimpleUploadInterceptor.ts\n// module id = 6\n// module chunks = 0","import log from \"../../util/Log\";\n/**\n * 分块上传\n */\nclass ChunkUploadPattern {\n    constructor(uploader) {\n        this.uploader = uploader;\n    }\n    init(uploader) {\n        this.uploader = uploader;\n    }\n    upload(task) {\n        this.task = task;\n        this.uploader.getToken(task).then(token => {\n            task.startDate = new Date();\n            this.uploadBlock(token);\n        });\n    }\n    uploadBlock(token) {\n        log.d(`准备开始上传块`);\n        let chain = Promise.resolve();\n        log.d(`共${this.task.blocks.length}块等待上传`);\n        log.d(`共${this.task.totalChunkCount}分片等待上传`);\n        this.task.blocks.forEach((block, blockIndex) => {\n            block.chunks.forEach((chunk, chunkIndex) => {\n                chain = chain.then(() => {\n                    log.d(`开始上传第${blockIndex + 1}块,第${chunkIndex + 1}片`);\n                    return this.uploadChunk(chunk, token);\n                });\n            });\n        });\n        chain.then(() => {\n            return this.concatChunks(token);\n        }).then(() => {\n            //所有任务都结束了\n            if (this.uploader.isTaskQueueFinish()) {\n                log.d(`上传任务队列已结束`);\n                //更改任务执行中标志\n                this.uploader.tasking = false;\n                //监听器调用\n                this.uploader.listener.onFinish(this.uploader.taskQueue);\n            }\n        }).catch(response => {\n            log.w(`${this.task.file.name}分块上传失败`);\n            this.task.error = response;\n            this.task.isSuccess = false;\n            this.task.isFinish = true;\n            this.task.endDate = new Date();\n            this.uploader.listener.onTaskFail(this.task);\n        });\n    }\n    uploadChunk(chunk, token) {\n        return new Promise((resolve, reject) => {\n            let isFirstChunkInBlock = chunk.block.chunks.indexOf(chunk) == 0;\n            let chunkIndex = chunk.block.chunks.indexOf(chunk);\n            //前一个chunk,如果存在的话\n            let prevChunk = isFirstChunkInBlock ? null : chunk.block.chunks[chunkIndex - 1];\n            let url = isFirstChunkInBlock ? this.getUploadBlockUrl(chunk.block.data.size) : this.getUploadChunkUrl(chunk.start, prevChunk ? prevChunk.ctx : null, prevChunk ? prevChunk.host : null);\n            let xhr = new XMLHttpRequest();\n            xhr.open('POST', url += (/\\?/.test(url) ? \"&\" : \"?\") + new Date().getTime(), true);\n            xhr.setRequestHeader('Content-Type', 'application/octet-stream'); //设置contentType\n            xhr.setRequestHeader('Authorization', `UpToken ${token}`); //添加token验证头\n            //分片上传中\n            xhr.upload.onprogress = e => {\n                if (e.lengthComputable) {\n                    let progress = Math.round((this.task.finishedBlocksSize + chunk.start + e.loaded) / this.task.file.size * 100);\n                    if (this.task.progress < progress) {\n                        this.task.progress = progress;\n                        this.uploader.listener.onTaskProgress(this.task);\n                    }\n                }\n            };\n            //分片上传完成\n            xhr.upload.onload = () => {\n                let progress = Math.round((this.task.finishedBlocksSize + chunk.start + chunk.data.size) / this.task.file.size * 100);\n                if (this.task.progress < progress) {\n                    this.task.progress = progress;\n                    this.uploader.listener.onTaskProgress(this.task);\n                }\n            };\n            //响应返回\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState == XMLHttpRequest.DONE) {\n                    if (xhr.status == 200 && xhr.responseText != '') {\n                        let result = JSON.parse(xhr.responseText);\n                        chunk.isFinish = true;\n                        chunk.processing = false;\n                        chunk.ctx = result.ctx;\n                        chunk.host = result.host;\n                        let chunkIndex = chunk.block.chunks.indexOf(chunk);\n                        let hasNextChunkInThisBlock = chunkIndex != chunk.block.chunks.length - 1;\n                        if (!hasNextChunkInThisBlock) {\n                            chunk.block.isFinish = true;\n                            chunk.block.processing = false;\n                        }\n                        resolve();\n                    } else {\n                        reject(xhr.response);\n                    }\n                }\n            };\n            xhr.send(chunk.data);\n        });\n    }\n    concatChunks(token) {\n        return new Promise((resolve, reject) => {\n            let encodedKey = this.task.key ? btoa(this.task.key) : null;\n            // 安全字符串 参考：https://developer.qiniu.com/kodo/api/mkfile\n            if (encodedKey) {\n                encodedKey = encodedKey.replace(/\\+/g, '-');\n                encodedKey = encodedKey.replace(/\\//g, '_');\n            }\n            let url = this.getMakeFileUrl(this.task.file.size, encodedKey);\n            //构建所有数据块最后一个数据片上传后得到的<ctx>的组合成的列表字符串\n            let ctxListString = '';\n            for (let block of this.task.blocks) {\n                let lastChunk = block.chunks[block.chunks.length - 1];\n                ctxListString += lastChunk.ctx + ',';\n            }\n            if (ctxListString.endsWith(',')) {\n                ctxListString = ctxListString.substring(0, ctxListString.length - 1);\n            }\n            let xhr = new XMLHttpRequest();\n            xhr.open('POST', url += (/\\?/.test(url) ? \"&\" : \"?\") + new Date().getTime(), true);\n            xhr.setRequestHeader('Content-Type', 'text/plain'); //设置contentType\n            xhr.setRequestHeader('Authorization', `UpToken ${token}`); //添加token验证头\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState == XMLHttpRequest.DONE) {\n                    this.task.isFinish = true;\n                    if (xhr.status == 200 && xhr.responseText != '') {\n                        let result = JSON.parse(xhr.responseText);\n                        this.task.isSuccess = true;\n                        this.task.result = result;\n                        this.task.endDate = new Date();\n                        this.uploader.listener.onTaskSuccess(this.task);\n                        resolve();\n                    } else if (this.retryTask(this.task)) {\n                        log.w(`${this.task.file.name}分块上传失败,准备开始重传`);\n                        this.uploader.listener.onTaskRetry(this.task);\n                    } else {\n                        reject(xhr.response);\n                    }\n                }\n            };\n            xhr.send(ctxListString);\n        });\n    }\n    /**\n     * 获取块上传的url\n     * @param blockSize\n     * @returns {string}\n     */\n    getUploadBlockUrl(blockSize) {\n        return `${this.uploader.domain}/mkblk/${blockSize}`;\n    }\n    /**\n     * 获取片上传的url\n     * @param start 片的在块中的起始位置\n     * @param ctx 前一次上传返回的块级上传控制信息。\n     * @param host 指定host\n     */\n    getUploadChunkUrl(start, ctx, host) {\n        return `${host ? host : this.uploader.domain}/bput/${ctx}/${start}/`;\n    }\n    /**\n     * 获取合并块为文件的url\n     * @param fileSize 文件大小\n     * @param encodedKey base64UrlEncode后的资源名称,若未指定，则使用saveKey；若未指定saveKey，则使用资源内容的SHA1值作为资源名。\n     * @returns {string}\n     */\n    getMakeFileUrl(fileSize, encodedKey) {\n        if (encodedKey) {\n            return `${this.uploader.domain}/mkfile/${fileSize}/key/${encodedKey}`;\n        } else {\n            return `${this.uploader.domain}/mkfile/${fileSize}`;\n        }\n    }\n    retryTask(task) {\n        //达到重试次数\n        if (task.retry >= this.uploader.retry) {\n            log.w(`${task.file.name}达到重传次数上限${this.uploader.retry},停止重传`);\n            return false;\n        }\n        task.retry++;\n        log.w(`${task.file.name}开始重传,当前重传次数${task.retry}`);\n        // this.upload(task);\n        //todo\n        return true;\n    }\n}\nexport default ChunkUploadPattern;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/pattren/ChunkUploadPattern.ts\n// module id = 7\n// module chunks = 0","import log from \"../../util/Log\";\n/**\n * 直接上传\n */\nclass DirectUploadPattern {\n    constructor(uploader) {\n        this.uploader = uploader;\n    }\n    /**\n     * 实现接口的上传方法\n     * @param task\n     */\n    upload(task) {\n        this.task = task;\n        this.uploader.getToken(task).then(token => {\n            task.startDate = new Date();\n            this.uploadFile(token);\n        });\n    }\n    /**\n     * 创建表单\n     * @param token\n     * @returns {FormData}\n     */\n    createFormData(token) {\n        let task = this.task;\n        let formData = new FormData();\n        //key存在，添加到formData中，若不设置，七牛服务器会自动生成hash key\n        if (task.key !== null && task.key !== undefined) {\n            formData.append('key', task.key);\n        }\n        formData.append('token', token);\n        formData.append('file', task.file);\n        log.d(`创建formData对象`);\n        return formData;\n    }\n    /**\n     * 上传文件\n     * @param token\n     */\n    uploadFile(token) {\n        let task = this.task;\n        let xhr = new XMLHttpRequest();\n        //上传中\n        xhr.upload.onprogress = e => {\n            if (e.lengthComputable) {\n                let progress = Math.round(e.loaded * 100 / e.total);\n                if (task.progress < progress) {\n                    task.progress = progress;\n                    this.uploader.listener.onTaskProgress(task);\n                }\n            }\n        };\n        //上传完成\n        xhr.upload.onload = () => {\n            if (task.progress < 100) {\n                task.progress = 100;\n                this.uploader.listener.onTaskProgress(task);\n            }\n        };\n        let url = this.uploader.domain;\n        //避免浏览器缓存http请求\n        url += (/\\?/.test(this.uploader.domain) ? \"&\" : \"?\") + new Date().getTime();\n        xhr.open('POST', url, true);\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState == XMLHttpRequest.DONE) {\n                if (xhr.status == 200 && xhr.responseText != '') {\n                    task.result = JSON.parse(xhr.responseText);\n                    task.isSuccess = true;\n                    task.isFinish = true;\n                    task.endDate = new Date();\n                    this.uploader.listener.onTaskSuccess(task);\n                } else if (this.retryTask(task)) {\n                    log.w(`${task.file.name}上传失败,准备开始重传`);\n                    this.uploader.listener.onTaskRetry(task);\n                } else {\n                    log.w(`${task.file.name}上传失败`);\n                    task.error = xhr.response;\n                    task.isSuccess = false;\n                    task.isFinish = true;\n                    task.endDate = new Date();\n                    this.uploader.listener.onTaskFail(task);\n                }\n                //所有任务都结束了\n                if (this.uploader.isTaskQueueFinish()) {\n                    log.d('上传队列结束');\n                    //更改任务执行中标志\n                    this.uploader.tasking = false;\n                    //onFinish callback\n                    this.uploader.listener.onFinish(this.uploader.taskQueue);\n                }\n            }\n        };\n        let formData = this.createFormData(token);\n        xhr.send(formData);\n        log.d('发送ajax post 请求');\n    }\n    /**\n     * 重传\n     * @param task\n     * @returns {boolean}\n     */\n    retryTask(task) {\n        log.d(\"开始尝试重传\");\n        //达到重试次数\n        if (task.retry >= this.uploader.retry) {\n            log.w(`${task.file.name}达到重传次数上限${this.uploader.retry},停止重传`);\n            return false;\n        }\n        task.retry++;\n        log.w(`${task.file.name}开始重传,当前重传次数${task.retry}`);\n        this.upload(task);\n        return true;\n    }\n}\nexport default DirectUploadPattern;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/pattren/DirectUploadPattern.ts\n// module id = 8\n// module chunks = 0","import BaseTask from \"./BaseTask\";\n/**\n * 分块任务\n */\nclass ChunkTask extends BaseTask {\n    /**\n     * 构造函数\n     * @param file\n     * @param blockSize 块大小\n     * @param chunkSize 片大小\n     */\n    constructor(file, blockSize, chunkSize) {\n        super(file);\n        //分块\n        this._blocks = [];\n        this._blockSize = 0;\n        this._chunkSize = 0;\n        this._blockSize = blockSize;\n        this._chunkSize = chunkSize;\n        this.spliceFile2Block();\n    }\n    /**\n     * 将文件分块\n     */\n    spliceFile2Block() {\n        this._blocks = [];\n        let fileSize = this._file.size;\n        let file = this._file;\n        //总块数\n        let blockCount = Math.ceil(fileSize / this._blockSize);\n        for (let i = 0; i < blockCount; i++) {\n            let start = i * this._blockSize; //起始位置\n            let end = start + this._blockSize; //结束位置\n            //构造一个块实例\n            let block = new Block(start, end, file.slice(start, end), this._chunkSize, file);\n            //添加到数组中\n            this._blocks.push(block);\n        }\n    }\n    /**\n     * 获取所有的block\n     * @returns {Block[]}\n     */\n    get blocks() {\n        return this._blocks;\n    }\n    /**\n     * 获取正在处理的block\n     * @returns {Block}\n     */\n    get processingBlock() {\n        for (let block of this._blocks) {\n            if (!block.processing) {\n                continue;\n            }\n            return block;\n        }\n        throw Error(\"找不到正在处理的Block\");\n    }\n    get finishedBlocksSize() {\n        let size = 0;\n        for (let block of this._blocks) {\n            size += block.isFinish ? block.data.size : 0;\n        }\n        return size;\n    }\n    get chunks() {\n        let array = [];\n        for (let block of this._blocks) {\n            for (let chunk of block.chunks) {\n                array.push(chunk);\n            }\n        }\n        return array;\n    }\n    /**\n     * 获取正在处理的chunk\n     * @returns {Block}\n     */\n    get processingChunk() {\n        for (let block of this._blocks) {\n            if (!block.processing) {\n                continue;\n            }\n            for (let chunk of block.chunks) {\n                if (!chunk.processing) {\n                    continue;\n                }\n                return chunk;\n            }\n        }\n        throw Error(\"找不到正在处理的Chunk\");\n    }\n    /**\n     * 总共分片数量(所有分块的分片数量总和)\n     * @returns {number}\n     */\n    get totalChunkCount() {\n        let count = 0;\n        for (let block of this._blocks) {\n            count += block.chunks.length;\n        }\n        return count;\n    }\n}\n/**\n * 分块，分块大小七牛固定是4M\n */\nclass Block {\n    /**\n     *\n     * @param start 起始位置\n     * @param end 结束位置\n     * @param data 块数据\n     * @param chunkSize 分片数据的最大大小\n     * @param file 分块所属文件\n     */\n    constructor(start, end, data, chunkSize, file) {\n        this._chunks = [];\n        this._isFinish = false; //是否上传完成\n        this._processing = false; //是否正在上传\n        this._data = data;\n        this._start = start;\n        this._end = end;\n        this._file = file;\n        this.spliceBlock2Chunk(chunkSize);\n    }\n    /**\n     * 将块分片\n     */\n    spliceBlock2Chunk(chunkSize) {\n        let blockSize = this._data.size;\n        let data = this._data;\n        //总片数\n        let chunkCount = Math.ceil(blockSize / chunkSize);\n        for (let i = 0; i < chunkCount; i++) {\n            let start = i * chunkSize; //起始位置\n            let end = start + chunkSize; //结束位置\n            //构造一个片实例\n            let chunk = new Chunk(start, end, data.slice(start, end), this);\n            //添加到数组中\n            this._chunks.push(chunk);\n        }\n    }\n    /**\n     * 是否上传中\n     * @returns {boolean}\n     */\n    get processing() {\n        return this._processing;\n    }\n    set processing(value) {\n        this._processing = value;\n    }\n    /**\n     * 分块所属的文件\n     * @returns {File}\n     */\n    get file() {\n        return this._file;\n    }\n    /**\n     * 是否已经结束\n     * @returns {boolean}\n     */\n    get isFinish() {\n        return this._isFinish;\n    }\n    set isFinish(value) {\n        this._isFinish = value;\n    }\n    /**\n     * 返回分块数据\n     * @returns {Blob}\n     */\n    get data() {\n        return this._data;\n    }\n    /**\n     * 返回字节起始位置\n     * @returns {number}\n     */\n    get start() {\n        return this._start;\n    }\n    /**\n     * 返回字节结束位置\n     * @returns {number}\n     */\n    get end() {\n        return this._end;\n    }\n    get chunks() {\n        return this._chunks;\n    }\n}\n/**\n * 分片，分片大小可以自定义，至少1字节\n */\nclass Chunk {\n    /**\n     *\n     * @param start 字节起始位置\n     * @param end 字节结束位置\n     * @param data 分片数据\n     * @param block 分块对象\n     */\n    constructor(start, end, data, block) {\n        this._processing = false; //是否正在上传\n        this._isFinish = false; //是否上传完成\n        this._start = start;\n        this._end = end;\n        this._data = data;\n        this._block = block;\n    }\n    /**\n     * 返回chunk所属的Block对象\n     * @returns {Block}\n     */\n    get block() {\n        return this._block;\n    }\n    /**\n     * 返回字节起始位置\n     * @returns {number}\n     */\n    get start() {\n        return this._start;\n    }\n    /**\n     * 返回字节结束位置\n     * @returns {number}\n     */\n    get end() {\n        return this._end;\n    }\n    /**\n     * 返回分片数据\n     * @returns {Blob}\n     */\n    get data() {\n        return this._data;\n    }\n    /**\n     * 是否已经结束\n     * @returns {boolean}\n     */\n    get isFinish() {\n        return this._isFinish;\n    }\n    set isFinish(value) {\n        this._isFinish = value;\n    }\n    get host() {\n        return this._host;\n    }\n    set host(value) {\n        this._host = value;\n    }\n    /**\n     * 是否上传中\n     * @returns {boolean}\n     */\n    get processing() {\n        return this._processing;\n    }\n    set processing(value) {\n        this._processing = value;\n    }\n    /**\n     * 返回上传控制信息(七牛服务器返回前一次上传返回的分片上传控制信息,用于下一次上传,第一个chunk此值为空)\n     * @returns {string}\n     */\n    get ctx() {\n        return this._ctx;\n    }\n    set ctx(value) {\n        this._ctx = value;\n    }\n}\nexport { ChunkTask, Block, Chunk };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/task/ChunkTask.ts\n// module id = 9\n// module chunks = 0","import BaseTask from \"./BaseTask\";\n/**\n * 直传任务\n */\nclass DirectTask extends BaseTask {}\nexport default DirectTask;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/task/DirectTask.ts\n// module id = 10\n// module chunks = 0","class UUID {\n    static uuid() {\n        let d = new Date().getTime();\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n            let r = (d + Math.random() * 16) % 16 | 0;\n            d = Math.floor(d / 16);\n            return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n        });\n    }\n}\nexport default UUID;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/upload/uuid/UUID.ts\n// module id = 11\n// module chunks = 0","/**\n * Object.assign polyfill\n */\nif (typeof Object.assign != 'function') {\n    Object.assign = function (target) {\n        if (target == null) {\n            throw new TypeError('Cannot convert undefined or null to object');\n        }\n        target = Object(target);\n        for (let index = 1; index < arguments.length; index++) {\n            let source = arguments[index];\n            if (source != null) {\n                for (let key in source) {\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n        }\n        return target;\n    };\n}\n/**\n * canvas.toBlob polyfill\n */\nif (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {\n        value: function (callback, type, quality) {\n            let binStr = atob(this.toDataURL(type, quality).split(',')[1]),\n                len = binStr.length,\n                arr = new Uint8Array(len);\n            for (let i = 0; i < len; i++) {\n                arr[i] = binStr.charCodeAt(i);\n            }\n            callback(new Blob([arr], { type: type || 'image/png' }));\n        }\n    });\n}\n/**\n * endsWith polyfill\n */\nif (!String.prototype.endsWith) {\n    let toString = {}.toString;\n    let endsWith = function (search) {\n        if (this == null) {\n            throw TypeError();\n        }\n        let string = String(this);\n        if (search && toString.call(search) == '[object RegExp]') {\n            throw TypeError();\n        }\n        let stringLength = string.length;\n        let searchString = String(search);\n        let searchLength = searchString.length;\n        let pos = stringLength;\n        if (arguments.length > 1) {\n            let position = arguments[1];\n            if (position !== undefined) {\n                // `ToInteger`\n                pos = position ? Number(position) : 0;\n                if (pos != pos) {\n                    pos = 0;\n                }\n            }\n        }\n        let end = Math.min(Math.max(pos, 0), stringLength);\n        let start = end - searchLength;\n        if (start < 0) {\n            return false;\n        }\n        let index = -1;\n        while (++index < searchLength) {\n            if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    if (Object.defineProperty) {\n        Object.defineProperty(String.prototype, 'endsWith', {\n            'value': endsWith,\n            'configurable': true,\n            'writable': true\n        });\n    } else {\n        String.prototype.endsWith = endsWith;\n    }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/util/Polyfill.ts\n// module id = 12\n// module chunks = 0"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClaA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC9LA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvRA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}